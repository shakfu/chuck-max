struct Agent {
    pos : vec2f,
    rot : f32,
    pad : f32,
}

@group(0) @binding(0) var<storage, read_write> agents: array<Agent>;
// new version of webgpu supports read_write storage textures
// https://github.com/gfx-rs/wgpu/issues/2735
@group(0) @binding(1) var trail_texture_read: texture_2d<f32>;
@group(0) @binding(2) var trail_texture_write: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(3) var<uniform> dt : f32;

@group(0) @binding(4) var<uniform> sensor_offset : f32;  // in pixels
@group(0) @binding(5) var<uniform> sensor_size : i32;    // in pixels
@group(0) @binding(6) var<uniform> sense_angle_deg : f32;
@group(0) @binding(7) var<uniform> speed_pixels : f32;
@group(0) @binding(8) var<uniform> turn_speed : f32;

@group(0) @binding(9) var<uniform> simulation_mode : i32;

fn deg2rad(deg: f32) -> f32 { return deg * 3.14159 / 180.0; }
fn rand(co: f32) -> f32 { return fract(sin(co*(91.3458)) * 47453.5453); }
fn rand2(co: vec2f) -> f32 { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
fn rand3(co: vec3f) -> f32 { return rand2(co.xy+rand(co.z)); }

fn sense(pos_pixel: vec2f, rot: f32, delta_angle: f32, dim: vec2i) -> f32 {
    var sensor_dir = vec2f(cos(rot + delta_angle), sin(rot + delta_angle));
    var sensor_pos = pos_pixel + sensor_dir * sensor_offset;
    var sum = 0.0;

    for (var dx = -sensor_size; dx <= sensor_size; dx++) {
        for (var dy = -sensor_size; dy <= sensor_size; dy++) {
            let coord = vec2i(sensor_pos + vec2f(f32(dx), f32(dy)));
            // can improve sampling with linear filtering
            if (coord.x >= 0 && coord.x < dim.x && coord.y >= 0 && coord.y < dim.y) {
                sum += textureLoad(trail_texture_read, coord, 0).r; // NOTE: assuming every channel holds same value
            }
        }
    }

    return sum;
}

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let index = GlobalInvocationID.x;
    if (index >= arrayLength(&agents)) {
        return;
    }

    var pos = agents[index].pos;
    var rot = agents[index].rot;
    let random = rand3(vec3(pos, f32(index)));

    let dim = vec2i(textureDimensions(trail_texture_read));
    var pos_pixel = pos * vec2f(dim);

    // steer
    let left = sense(pos_pixel, rot, deg2rad(sense_angle_deg), dim);
    let forward = sense(pos_pixel, rot, 0.0, dim);
    let right = sense(pos_pixel, rot, deg2rad(-sense_angle_deg), dim);


    if (simulation_mode == 0) {
        // original implementation
        // relative to the forward weight, left and right can either be gt or less than forward,
        // yielding 2 * 2 = 4 possible combinations:
        if (forward > left && forward > right) {
            // do nothing
        } else if (forward < left && forward < right) {
            // turn randomly
            rot += 2.0 * (random - 0.5) * turn_speed * dt;
        } else if (right > left) { // right > forward > left
            rot -= random * turn_speed * dt;
        } else if (left > right) { // right < foward < left
            rot += random * turn_speed * dt;
        }
    } else {
        // Picking based on a weighted pdf (also looks cool, more chaotic/extreme)
        let total = left + forward + right;
        let weighted_l = left / total;
        let weighted_r = right / total;
        let weighted_f = forward / total;
        if (random < weighted_l) {
            rot += turn_speed * dt;
        } else if (random >= weighted_l && random < weighted_l + weighted_r) {
            rot -= turn_speed * dt;
        } else {
            // go forward
        }
    }

    pos_pixel += vec2f(cos(rot), sin(rot)) * speed_pixels * dt;
    pos = pos_pixel / vec2f(dim);

    // boundaries
    if (pos.x < 0 || pos.x > 1 || pos.y < 0 || pos.y > 1) {
        pos = clamp(pos, vec2f(0.0), vec2f(1.0));
        rot = random * 2.0 * 3.14159;
    }

    // write back
    agents[index].pos = pos;
    agents[index].rot = rot;

    // dump to texture
    var tex_coords = vec2u(pos * vec2f(textureDimensions(trail_texture_write)));
    textureStore(trail_texture_write, tex_coords, vec4f(1));
}